Perl 스크립트 모듈을 독립된 공간에 자동 설치해서 실행시키기

https://gist.github.com/aero/2e10d66c3ea50de56c22ce21b7dd233b


Perl로 어떤 스크립트를 만들어서 누구에게 주고 사용해보라고 하거나, 어디서 예제 Perl스크립트 가져와서 실행시킬때 추가로 설치한 모듈이 필요할 때가 있습니다. 이때 하게 되는 고민이
“필요한 모듈은 어떻게 설치하고 실행시켜라고 가르쳐 주지?” 
“테스트로 돌려보고 싶은데 한번 쓰고 말 모듈 같은걸 설치해서 나중에 필요없으면 찾아 지우기도 귀찮고 싫은데 어쩌지?” 같은 것들이 있습니다. 
뭐 cpan, cpanm 같은 모듈 설치 유틸리티와 local::lib같은 모듈 설치 위치를 임의로 바꿀 수 있는 모듈을 잘 숙지하고 있다면 상관없지만 그것도 하나하나 따지는 것도 귀찮을 때가 있습니다.

그래서 그런것 몰라도 실행하면 스크립트가 위치한 디렉토리에 로컬 모듈 인스톨 디렉토리를 만들고 필요한 모듈들을 자동설치하고 실행시키며 나중에 필요가 없을때는 스크립트와 로컬 모듈 인스톨 디렉토리만 날리면 깔끔하게 청소가 되는 형태를 만들어 보고자 합니다.

Perl은 설치하게 되면 cpan 이라는 모듈 인스톨 명령을 제공합니다. 하지만 root유저가 아니라 시스템디렉토리 쓰기 권한이 없으면 로컬계정에 설치하게 설정을 해줘야 하거나 첫 실행시 다소 설정에 손이 가게 됩니다. 그래서 간편하게 모듈 인스톨 할 수 있도록 만들어진게 cpanm(cpanminus)명령 입니다.

cpanm은 

```
cd ~/bin
curl -L https://cpanmin.us/ -o cpanm
chmod +x cpanm
```
해서 PATH에 ~/bin 을 추가해서 바로 사용가능하고

아니면
```
curl -L https://cpanmin.us | perl - 설치모듈명
```

처럼 인터넷으로 받은 cpanm스크립트를 perl 로 바로 보내서 실행시키면서 설치모듈명을 인자로 줘서 설치 가능합니다.

하지만 이것도 curl같은 web url에서 가져오는 외부 유틸리티에 의존적입니다.

여기서는 2번째의 방법의 아이디어를 사용하지만 Perl기본 설치가 된 상태에서 curl 이나 wget 등 다른 유틸리티에 의존하지 않고 순전히 Perl기본설치 상태의 Core module들만 있는 상태에서 다른 외부 유틸리티에 의존하지 않고 Perl자체 만으로 소켓을 통해 cpanm 스크립트를 전송 받아서 실행하는 형태로 구현해보려고 합니다.

Perl모듈이 제대로 설치되려고 하면 Perl배포본 기본 설치 이외에도 gcc같은 컴파일러와 make같은 빌드툴이 설치되어 있어야 하므로 Debian/Ubuntu 계열이면 perl패키지(주의:perl-base패키지는 기본 Perl배포본에 Core모듈이 일부만 들어간 것)와 apt-get install build-essential 로 개발관련 패키지가 설치 되어있고, RedHat/Cenos 계열이면 perl-core패키지(주의:perl패키지는 기본 Perl배포본에 Core모듈이 일부만 들어간것)와 yum groupinstall 'Development Tools' 로 개발관련 패키지가 설치되어 있는 상태이어야 합니다. 윈도우면 Strawberry Perl에 필요한 컴파일러와 툴이 기본으로 다 포함되어 있습니다.

일단 구현된 본체를 전부 보고 하나 하나 짚어가며 설명을 하도록 하겠습니다.

소스: https://gist.github.com/aero/b31df2de10c47c7c99ee0d4f4cd5ec7a

```
#!/usr/bin/env perl

BEGIN {
    require FindBin;
    require lib;

    my $locallib_path = "$FindBin::RealBin/locallib/$^V";
    lib->import("$locallib_path/lib/perl5");

    my $cpanm;
    my $get_cpanm = sub {
        return $cpanm if defined $cpanm;
        require IO::Socket;
        my $s = IO::Socket::INET->new(PeerAddr => 'cpanmin.us:80') or die $!;
        print {$s} "GET / HTTP/1.1\r\nHost: cpanmin.us\r\n\r\n";
        my $content;
        while (<$s>) { last if m/^\r\n$/; }
        while (<$s>) { $content .= $_; last if m/^__END__$/; }
        close $s;
        return $content;
    };
    push @INC, sub {
        my $file = $_[1];
        my $module = $file;
        return if grep { $file eq $_ } qw{
            Encode/ConfigLocal.pm
            Devel/StackTraceFrame.pm
            Log/Agent.pm
            };# from lib::xi module
        print "Oops: There was an error looking for $module\n";
        $module =~ s/\.pm \z//xms;
        $module =~ s{/}{::}xmsg;
        $cpanm = $get_cpanm->();
        open my $fh, '|-', "$^X - -v -n -l$locallib_path $module";
        print {$fh} $cpanm;
        close $fh;

        lib->import("$locallib_path/lib/perl5");
        require Config;
        Config->import;
        my @myinc = (
            "$locallib_path/lib/perl5",
            "$locallib_path/lib/perl5/$Config::Config{archname}"
            );
        foreach my $lib (grep {defined} @myinc) {
            if(open my $inh, '<', "$lib/$file") {
                $INC{$file} = "$lib/$file";
                return $inh;
            }
        }
        return;
    };
}

use strict;
use warnings;

use Mojolicious;
use Text::CSV_XS;

print "$^V\n";
print "$_\n" for @INC;
```

위 소스에서 보시다시피 일반적인 펄 스크립트의 앞부분에 위 소스코드의 BEGIN { … } 블럭 부분만 복사해서 붙여넣으면 됩니다.

BEGIN블럭은 스크립트가 실행될때 제일 먼저 실행됩니다. BEGIN블럭안의 코드를 보면…

처음에 스크립트가 존재하는 위치를 기준으로 “./locallib/펄버전스트링” 을 로컬 모듈 설치 디렉토리경로로 지정한 후 해당 디렉토리를 모듈 INC경로를 추가하는 lib모듈을 통해 추가합니다.

그리고 IO::Socket모듈을 통해 cpanmin.us 에 HTTP접속해서 응답을(cpanm스크립트)를 받아서 응답헤더를 제외한 컨텐츠(cpanm 스크립트)를 $cpanm 변수에 저장하는 $get_cpanm 코드 레퍼런스를 정의합니다. 이때 $get_cpanm을 호출했을 때 이미 받아왔으면 다시 요청하는 건 낭비이므로 이걸 확인해서 $cpanm에 내용이 있으면 바로 그내용을 리턴하게 되어있습니다.

그 다음 코드를 보면 Perl모듈 디렉토리경로 리스트를 저장하고 있는 배열인 @INC에 생뚱맞게 코드레퍼런스를 집어넣는걸 볼 수 있습니다. 이렇게 하면 스크립트에서 use 모듈명 형식으로 모듈을 로딩할때 로딩하고자 하는 모듈이 존재하지 않을경우 코드레퍼런스가 호출되게 됩니다. 따라서 모듈이 존재하지 않을때 이 코드레퍼런스에서 모듈을 자동 설치하게 하는 과정을 넣으면 원하는 목적을 달성할 수 있게 됩니다.

해당 코드레퍼런스가 호출될때 인자로 코드레펀런스자신, 모듈경로명(eg. My/Module.pm) 이 들어오며 코드를 보시면 그 모듈 경로명을 기준으로 cpan에 없는 모듈이면 제외하고  
```
        open my $fh, '|-', "$^X - -v -n -l$locallib_path $module";
        print {$fh} $cpanm;
```

에서 실제적으로 cat cpanm | perl - -v -n -l$locallib_path $module 같은 효과로 결론적으로는 cpanm -v -n -l$locallib_path $module 로 실행이 되게 됩니다. -v 는 verbose옵션 -n은 테스트는 하지 않는다는 옵션 -l은 로컬에 모듈을 설치할 경로를 지정하는 옵션입니다. -l 옵션 말고는 원하는대로 바꾸셔도 됩니다

그다음 모듈이 설치되고 나면 모듈이 존재하는 위치를 찾아서 그 경로를 %INC 해쉬에 넣고 모듈의 파일핸들을 리턴해서 모듈이 제대로 로딩하게 해주게 됩니다.

push @INC, sub { … } 부분은 모듈을 cpanm명령으로 자동 인스톨 해주는 lib::xi 모듈의 코드를 많이 참고 했습니다.


보너스로 필요 모듈이 자동으로 인스톨 되지 않고 원하는 모듈만 딱 찝어서 설치되게 하고 싶다면 다음과 같은 코드에서 마찬가지로 BEGIN { … } 부분을 복사해서 넣고  @REQ_MODULES 부분에 설치할 모듈리스트를 적어주면 됩니다.

소스: https://gist.github.com/aero/e308b4c18b70e9cf2b02e7c74db2ade4

```
#!/usr/bin/env perl

BEGIN {
    my @REQ_MODULES = qw/
    Mojolicious
    Text::CSV_XS
    /;

    require FindBin;
    require lib;

    my $locallib_path = "$FindBin::RealBin/locallib/$^V";
    lib->import("$locallib_path/lib/perl5");

    my @MISSING;
    foreach my $module (@REQ_MODULES) {
        unless (eval "require $module") {
            push @MISSING, $module;
        }
    }

    if (@MISSING) {
        require IO::Socket;
        my $s = IO::Socket::INET->new(PeerAddr => 'cpanmin.us:80') or die $!;
        print {$s} "GET / HTTP/1.1\r\nHost: cpanmin.us\r\n\r\n";
        my $content;
        while (<$s>) { last if m/^\r\n$/; }
        while (<$s>) { $content .= $_; last if m/^__END__$/; }
        close $s;
        open my $fh, '|-', "$^X - -v -n -l$locallib_path @MISSING";
        print {$fh} $content;
        close $fh;
        lib->import("$locallib_path/lib/perl5");
    }
}

use strict;
use warnings;

use Mojolicious;
use Text::CSV_XS;

print "$^V\n";
print "$_\n" for @INC;
```

이제 Perl스크립트를 실행할때 모듈설치과정의 귀차니즘과 나중에 필요없을때 깔끔하게 그 모듈들을 깔끔하게 같이 날려버리고 싶으면 Perl스크립트에 위 코드들의 BEGIN { … } 블럭 부분만 추가해서 돌리고 나중에 스크립트와 스크립트 디렉토리에 생성된 ./locallib 폴더만 날려버리면 되겠습니다. :)

